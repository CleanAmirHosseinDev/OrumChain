{
  "files": [
    {
      "path": "contracts/GoldToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/IKYCRegistry.sol\";\n\n/**\n * @title GoldToken\n * @dev An ERC20 token backed by physical gold, with KYC enforcement and role-based access control.\n * 1 token unit = 1 gram of gold with 18 decimals.\n */\ncontract GoldToken is ERC20, ERC20Permit, AccessControl, Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant KYC_ADMIN_ROLE = keccak256(\"KYC_ADMIN_ROLE\");\n    bytes32 public constant KYC_EXEMPT_ROLE = keccak256(\"KYC_EXEMPT_ROLE\");\n\n    IKYCRegistry public kycRegistry;\n    bool public kycCheckEnabled = false;\n\n    event Redemption(address indexed user, uint256 amount);\n    event Minted(address indexed to, uint256 amount);\n    event KYCRegistryUpdated(address indexed newRegistry);\n    event KYCCheckStatusChanged(bool enabled);\n\n    constructor(\n        address admin,\n        address initialMinter\n    ) ERC20(\"Gold Gram Token\", \"GLDG\") ERC20Permit(\"Gold Gram Token\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(PAUSER_ROLE, admin);\n        _grantRole(KYC_ADMIN_ROLE, admin);\n        _grantRole(MINTER_ROLE, initialMinter);\n    }\n\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    function setKYCRegistry(IKYCRegistry _newRegistry) external onlyRole(KYC_ADMIN_ROLE) {\n        require(address(_newRegistry) != address(0), \"Zero address\");\n        kycRegistry = _newRegistry;\n        emit KYCRegistryUpdated(address(_newRegistry));\n    }\n\n    function setKYCCheck(bool _enabled) external onlyRole(KYC_ADMIN_ROLE) {\n        kycCheckEnabled = _enabled;\n        emit KYCCheckStatusChanged(_enabled);\n    }\n\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n        emit Minted(to, amount);\n    }\n\n    function redeem(uint256 amount) external {\n        _burn(msg.sender, amount);\n        emit Redemption(msg.sender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (kycCheckEnabled && from != address(0) && to != address(0)) {\n            if(hasRole(KYC_EXEMPT_ROLE, from) || hasRole(KYC_EXEMPT_ROLE, to)) {\n                return;\n            }\n            require(address(kycRegistry) != address(0), \"KYC registry not set\");\n            require(kycRegistry.isVerified(from), \"GT: sender not KYC-verified\");\n            require(kycRegistry.isVerified(to), \"GT: recipient not KYC-verified\");\n        }\n    }\n}"
    },
    {
      "path": "contracts/interfaces/IKYCRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IKYCRegistry {\n    function isVerified(address _user) external view returns (bool);\n    function proveAndUpdate(bytes32[] calldata proof) external;\n    function merkleRoot() external view returns (bytes32);\n}"
    },
    {
      "path": "contracts/KYCRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract KYCRegistry is AccessControl {\n    bytes32 public merkleRoot;\n    mapping(address => bool) public isVerified;\n\n    bytes32 public constant KYC_ADMIN_ROLE = keccak256(\"KYC_ADMIN_ROLE\");\n\n    event RootUpdated(bytes32 indexed newRoot);\n    event AddressVerified(address indexed user);\n\n    constructor(address admin, bytes32 initialRoot) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(KYC_ADMIN_ROLE, admin);\n        merkleRoot = initialRoot;\n    }\n\n    function updateRoot(bytes32 _newRoot) external onlyRole(KYC_ADMIN_ROLE) {\n        merkleRoot = _newRoot;\n        emit RootUpdated(_newRoot);\n    }\n\n    function proveAndUpdate(bytes32[] calldata proof) external {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, merkleRoot, leaf), \"KYCR: Invalid proof\");\n        if (!isVerified[msg.sender]) {\n            isVerified[msg.sender] = true;\n            emit AddressVerified(msg.sender);\n        }\n    }\n}"
    },
    {
      "path": "contracts/CustodyAttestationManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./GoldToken.sol\";\n\ncontract CustodyAttestationManager is EIP712, AccessControl {\n    bytes32 public constant CUSTODIAN_ROLE = keccak256(\"CUSTODIAN_ROLE\");\n    bytes32 private constant ATTESTATION_TYPEHASH = keccak256(\n        \"MintAttestation(address recipient,uint256 amount,bytes32 nonce)\"\n    );\n\n    GoldToken public immutable goldToken;\n    mapping(bytes32 => bool) public usedNonces;\n\n    event AttestationMint(address indexed recipient, uint256 amount, bytes32 indexed nonce);\n\n    constructor(address admin, address _goldTokenAddress) EIP712(\"CustodyAttestation\", \"1\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        goldToken = GoldToken(_goldTokenAddress);\n    }\n\n    function mintWithAttestation(\n        address recipient,\n        uint256 amount,\n        bytes32 nonce,\n        bytes calldata signature\n    ) external {\n        require(!usedNonces[nonce], \"CAM: Nonce already used\");\n        \n        bytes32 structHash = keccak256(abi.encode(ATTESTATION_TYPEHASH, recipient, amount, nonce));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        \n        address signer = ECDSA.recover(digest, signature);\n        require(hasRole(CUSTODIAN_ROLE, signer), \"CAM: Invalid custodian signature\");\n\n        usedNonces[nonce] = true;\n        goldToken.mint(recipient, amount);\n\n        emit AttestationMint(recipient, amount, nonce);\n    }\n}"
    },
    {
      "path": "contracts/OracleAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract OracleAggregator is EIP712, AccessControl {\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 private constant PRICE_REPORT_TYPEHASH = keccak256(\n        \"PriceReport(uint256 price,uint256 timestamp)\"\n    );\n\n    uint256 public latestPrice;\n    uint256 public lastUpdateTimestamp;\n\n    event PriceUpdated(uint256 newPrice, uint256 timestamp);\n\n    constructor(address admin, address initialOracle) EIP712(\"OracleAggregator\", \"1\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ORACLE_ROLE, initialOracle);\n    }\n\n    function updatePrice(uint256 price, uint256 timestamp, bytes calldata signature) external {\n        require(timestamp > lastUpdateTimestamp, \"OA: Stale timestamp\");\n\n        bytes32 structHash = keccak256(abi.encode(PRICE_REPORT_TYPEHASH, price, timestamp));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        \n        address signer = ECDSA.recover(digest, signature);\n        require(hasRole(ORACLE_ROLE, signer), \"OA: Invalid oracle signature\");\n\n        latestPrice = price;\n        lastUpdateTimestamp = timestamp;\n        emit PriceUpdated(price, timestamp);\n    }\n}"
    },
    {
      "path": "hardhat.config.js",
      "content": "require(\"@nomicfoundation/hardhat-toolbox\");\nrequire(\"@matterlabs/hardhat-zksync-solc\");\nrequire(\"@matterlabs/hardhat-zksync-deploy\");\nrequire(\"@matterlabs/hardhat-zksync-verify\");\nrequire('dotenv').config();\n\nconst ZKSYNC_TESTNET_RPC_URL = process.env.ZKSYNC_TESTNET_RPC_URL;\nconst DEPLOYER_PRIVATE_KEY = process.env.DEPLOYER_PRIVATE_KEY;\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  zksolc: {\n    version: \"1.3.13\",\n    compilerSource: \"binary\",\n    settings: {},\n  },\n  defaultNetwork: \"zkSyncTestnet\",\n  networks: {\n    hardhat: {\n        zksync: false,\n    },\n    zkSyncTestnet: {\n      url: ZKSYNC_TESTNET_RPC_URL || \"https://zksync2-testnet.zksync.dev\",\n      ethNetwork: \"goerli\", // Can also be the RPC URL of the network (e.g. `https://goerli.infura.io/v3/<API_KEY>)\n      zksync: true,\n      verifyURL: 'https://zksync2-testnet-explorer.zksync.dev/contract_verification',\n      accounts: DEPLOYER_PRIVATE_KEY ? [DEPLOYER_PRIVATE_KEY] : []\n    },\n  },\n  solidity: {\n    version: \"0.8.17\",\n  },\n};"
    },
    {
      "path": "test/GoldToken.test.js",
      "content": "const { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { MerkleTree } = require('merkletreejs');\nconst keccak256 = require('keccak256');\n\ndescribe(\"GoldToken System\", function () {\n  let GoldToken, goldToken, KYCRegistry, kycRegistry, CustodyAttestationManager, custodyManager, OracleAggregator, oracleAggregator;\n  let owner, admin, custodian, oracle, user1, user2;\n  let kycTree, kycRoot;\n\n  // Helper to create EIP712 signatures\n  async function signEIP712(signer, domain, types, value) {\n    return await signer._signTypedData(domain, types, value);\n  }\n\n  beforeEach(async function () {\n    [owner, admin, custodian, oracle, user1, user2] = await ethers.getSigners();\n\n    // 1. Deploy KYCRegistry\n    const kycLeaves = [user1.address, user2.address].map(addr => keccak256(addr));\n    kycTree = new MerkleTree(kycLeaves, keccak256, { sortPairs: true });\n    kycRoot = kycTree.getHexRoot();\n    const KYCRegistryFactory = await ethers.getContractFactory(\"KYCRegistry\");\n    kycRegistry = await KYCRegistryFactory.deploy(admin.address, kycRoot);\n\n    // 2. Deploy CustodyAttestationManager and GoldToken\n    const CustodyAttestationManagerFactory = await ethers.getContractFactory(\"CustodyAttestationManager\");\n    // Temporarily deploy GoldToken first to get its address\n    const GoldTokenFactory = await ethers.getContractFactory(\"GoldToken\");\n    const tempManagerAddr = ethers.Wallet.createRandom().address; // Placeholder\n    goldToken = await GoldTokenFactory.connect(admin).deploy(admin.address, tempManagerAddr);\n    \n    custodyManager = await CustodyAttestationManagerFactory.connect(admin).deploy(admin.address, goldToken.address);\n    \n    // 3. Deploy Oracle\n    const OracleAggregatorFactory = await ethers.getContractFactory(\"OracleAggregator\");\n    oracleAggregator = await OracleAggregatorFactory.connect(admin).deploy(admin.address, oracle.address);\n    \n    // 4. Configure roles and links\n    await goldToken.connect(admin).grantRole(await goldToken.MINTER_ROLE(), custodyManager.address);\n    await goldToken.connect(admin).revokeRole(await goldToken.MINTER_ROLE(), tempManagerAddr);\n    await goldToken.connect(admin).setKYCRegistry(kycRegistry.address);\n    await custodyManager.connect(admin).grantRole(await custodyManager.CUSTODIAN_ROLE(), custodian.address);\n  });\n\n  it(\"should mint with a valid custodian attestation\", async function () {\n    const amount = ethers.utils.parseUnits(\"100\", 18);\n    const nonce = ethers.utils.randomBytes(32);\n    const domain = { name: 'CustodyAttestation', version: '1', chainId: (await ethers.provider.getNetwork()).chainId, verifyingContract: custodyManager.address };\n    const types = { MintAttestation: [ { name: 'recipient', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'nonce', type: 'bytes32' } ] };\n    const value = { recipient: user1.address, amount, nonce };\n    const signature = await signEIP712(custodian, domain, types, value);\n\n    await expect(custodyManager.mintWithAttestation(user1.address, amount, nonce, signature))\n      .to.emit(goldToken, 'Minted').withArgs(user1.address, amount);\n    expect(await goldToken.balanceOf(user1.address)).to.equal(amount);\n  });\n\n  it(\"should fail to mint with an invalid signature\", async function () {\n    const amount = ethers.utils.parseUnits(\"100\", 18);\n    const nonce = ethers.utils.randomBytes(32);\n    const signature = '0x' + '00'.repeat(65); // Invalid signature\n\n    await expect(custodyManager.mintWithAttestation(user1.address, amount, nonce, signature))\n      .to.be.revertedWith(\"CAM: Invalid custodian signature\");\n  });\n\n  it(\"should block transfer if KYC check is enabled and user is not verified\", async function () {\n    await goldToken.connect(admin).setKYCCheck(true);\n    // Mint tokens to user1 first (minting is not KYC-gated)\n    const amount = ethers.utils.parseUnits(\"50\", 18);\n    const nonce = ethers.utils.randomBytes(32);\n    const domain = { name: 'CustodyAttestation', version: '1', chainId: (await ethers.provider.getNetwork()).chainId, verifyingContract: custodyManager.address };\n    const types = { MintAttestation: [ { name: 'recipient', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'nonce', type: 'bytes32' } ] };\n    const value = { recipient: user1.address, amount, nonce };\n    const signature = await signEIP712(custodian, domain, types, value);\n    await custodyManager.mintWithAttestation(user1.address, amount, nonce, signature);\n\n    await expect(goldToken.connect(user1).transfer(user2.address, ethers.utils.parseUnits(\"10\", 18)))\n      .to.be.revertedWith(\"GT: sender not KYC-verified\");\n  });\n\n  it(\"should allow transfer after providing a valid KYC proof\", async function () {\n    await goldToken.connect(admin).setKYCCheck(true);\n    // Mint tokens to user1\n    const amount = ethers.utils.parseUnits(\"50\", 18);\n    const nonce = ethers.utils.randomBytes(32);\n    const domain = { name: 'CustodyAttestation', version: '1', chainId: (await ethers.provider.getNetwork()).chainId, verifyingContract: custodyManager.address };\n    const types = { MintAttestation: [ { name: 'recipient', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'nonce', type: 'bytes32' } ] };\n    const value = { recipient: user1.address, amount, nonce };\n    const signature = await signEIP712(custodian, domain, types, value);\n    await custodyManager.mintWithAttestation(user1.address, amount, nonce, signature);\n\n    // User1 and User2 prove their KYC status\n    const leaf1 = keccak256(user1.address);\n    const proof1 = kycTree.getHexProof(leaf1);\n    await kycRegistry.connect(user1).proveAndUpdate(proof1);\n    const leaf2 = keccak256(user2.address);\n    const proof2 = kycTree.getHexProof(leaf2);\n    await kycRegistry.connect(user2).proveAndUpdate(proof2);\n\n    // Transfer should now succeed\n    await expect(goldToken.connect(user1).transfer(user2.address, ethers.utils.parseUnits(\"10\", 18)))\n      .to.not.be.reverted;\n    expect(await goldToken.balanceOf(user2.address)).to.equal(ethers.utils.parseUnits(\"10\", 18));\n  });\n\n  it(\"should burn tokens on redemption and emit an event\", async function () {\n    // Mint tokens to user1\n    const amount = ethers.utils.parseUnits(\"50\", 18);\n    const nonce = ethers.utils.randomBytes(32);\n    const domain = { name: 'CustodyAttestation', version: '1', chainId: (await ethers.provider.getNetwork()).chainId, verifyingContract: custodyManager.address };\n    const types = { MintAttestation: [ { name: 'recipient', type: 'address' }, { name: 'amount', type: 'uint256' }, { name: 'nonce', type: 'bytes32' } ] };\n    const value = { recipient: user1.address, amount, nonce };\n    const signature = await signEIP712(custodian, domain, types, value);\n    await custodyManager.mintWithAttestation(user1.address, amount, nonce, signature);\n\n    const redeemAmount = ethers.utils.parseUnits(\"20\", 18);\n    await expect(goldToken.connect(user1).redeem(redeemAmount))\n      .to.emit(goldToken, \"Redemption\").withArgs(user1.address, redeemAmount);\n    expect(await goldToken.balanceOf(user1.address)).to.equal(amount.sub(redeemAmount));\n  });\n\n  it(\"should update oracle price with a valid signature\", async function () {\n    const price = ethers.BigNumber.from(\"65000000000000000000\"); // e.g., $65 with 18 decimals\n    const timestamp = Math.floor(Date.now() / 1000);\n    const domain = { name: 'OracleAggregator', version: '1', chainId: (await ethers.provider.getNetwork()).chainId, verifyingContract: oracleAggregator.address };\n    const types = { PriceReport: [ { name: 'price', type: 'uint256' }, { name: 'timestamp', type: 'uint256' } ] };\n    const value = { price, timestamp };\n    const signature = await signEIP712(oracle, domain, types, value);\n\n    await oracleAggregator.updatePrice(price, timestamp, signature);\n    expect(await oracleAggregator.latestPrice()).to.equal(price);\n  });\n});"
    }
  ]
}
